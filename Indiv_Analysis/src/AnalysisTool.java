import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Queue;

import org.omg.PortableInterceptor.DISCARDING;

/**
 * This project extracts the game information from the replay file generated by
 * FightingICE, and analyzes it.<br>
 * How to use this project is as follows.<br>
 * <ol>
 * <li>Create "replay" and "result" directories in the same hierarchy as the src
 * directory.</li>
 * <li>Add the replay file(s) (.dat) you want to analyze in the replay
 * directory.</li>
 * <li>Run this project.</li>
 * <li>After that, the result file(s) of each replay file will be created in the
 * result directory.</li>
 * </ol>
 *
 * Now, this project only outputs the frame information to the file.<br>
 * Please add functions, classes, etc... for analyzing.
 *
 * @author Makoto Ishihara
 */
public class AnalysisTool {

	/** The path of the directory containing the replay file(s) */
	public static String DIRECTORY_PATH = "./replay";

	/** The path of the output directory */
	public static String OUTPUT_PATH = "./result/";

	/** The array containing character names */
	public static final String[] CHARACTERS = { "ZEN", "GARNET", "LUD", "KFM" };

	/** The mode (HP mode or Time mode) when FightingICE is launched */
	public static boolean HP_MODE = true;

	private DataInputStream dis;
	private PrintWriter pw;

	// USER CODE
	public static final int TOTALCASE = 90720;
	public static File ghostfile;
	public static BufferedReader reader;
	public static PrintWriter writer;
	public static ArrayList<ArrayList<Integer>> Act = new ArrayList<ArrayList<Integer>>();
	public static int lastactionid = 1;
	public static final int[] ACTIONLIST = { 0, 0, 32, 35, 36, 0, 38, 37, 39, 0, 33, 34, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 1, 2, 0, 0, 3, 4, 5, 6, 18, 19, 20, 21, 7, 8, 9, 10, 22, 23, 24, 25, 11, 12, 14, 15, 16, 17, 26, 27, 28,
			29, 30, 31, 13 };
	public static int havedata = 0;

	// END

	public static void main(String[] args) {
		// System.out.println(ACTIONLIST[31]);
		AnalysisTool arl = new AnalysisTool();

		// Creates the output directory
		new File("result").mkdir();

		// USER CODE
		for (int i = 0; i < TOTALCASE; i++) {
			Act.add(new ArrayList<Integer>());
		}
		ghostfile = new File("./result/ghost.csv");
		try {
			if (ghostfile.createNewFile()) {
				writer = new PrintWriter(new BufferedWriter(new FileWriter(ghostfile)));
				for (int i = 0; i < TOTALCASE; i++) {
					writer.println(63);
				}
				writer.close();
			}
			reader = new BufferedReader(new FileReader(ghostfile));
			for (int i = 0; i < TOTALCASE; i++) {
				String[] tokens = reader.readLine().split(",");
				for (String token : tokens) {
					try {
						Integer.parseInt(token);
					} catch (Exception e) {
						// e.printStackTrace();
						break;
					}
					if (Integer.parseInt(token) == 63)
						break;
					Act.get(i).add(Integer.parseInt(token));
					// System.out.println("added");
				}
			}
			reader.close();
			ghostfile.delete();
		} catch (Exception e) {
			// TODO: handle exception
			try {
				reader.close();
				writer.close();
			} catch (Exception ee) {
				// TODO: handle exception
				e.printStackTrace();
			}
			e.printStackTrace();
		}
		// END
		// Analyzes the replay file(s)
		arl.readFile(new File(DIRECTORY_PATH));

		// closes all files
		arl.fileClose();

		// USER CODE
		try {
			if (ghostfile.createNewFile()) {
				writer = new PrintWriter(new BufferedWriter(new FileWriter(ghostfile)));
				for (int i = 0; i < TOTALCASE; i++) {
					String line = "";
					for (int n : Act.get(i)) {
						line = line + n + ",";
					}
					if (line.length() > 0) {
						line = line.substring(0, line.length() - 1);
						havedata++;
					} else {
						line += "63";
					}
					writer.println(line);
				}
				writer.close();
			}
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		}

		// END
		System.out.println("Finished");

		// USER CODE
		System.out.println("Ghost creation " + havedata * 100 / TOTALCASE + "% completed");
	}

	/**
	 * Reads all replay files in the directory and analyzes them.
	 *
	 * @param dir
	 *            The path of the directory contains files you want to analyze.
	 */
	public void readFile(File dir) {

		// Reads all files in the directory
		File[] files = dir.listFiles();
		int count = 0;

		if (files == null) {
			return;
		}

		// Analyzes each file
		System.out.println("Analyzing " + files.length + " files");
		for (File file : files) {
			if (!file.exists()) {
				continue;
			} else if (file.isFile()) {
				analyze(file);
			}

			count++;
			if (count == 1) {
				System.out.println("Analysis of " + count + " file is completed");
			} else {
				System.out.println("Analysis of " + count + " files are completed");
			}
		}
	}

	/**
	 * Extracts the frame information from the replay file and analyzes it<br>
	 * The frames information written in the replay file is as follows.<br>
	 *
	 * <ul>
	 * <li>isLeft: a boolean value whether the character is on the left side of
	 * the opponent character (left side: {@code true}, right side:
	 * {@code false})<br>
	 * </li>
	 *
	 * <li>actionRemainingFrames: # of remaining frames of the action the
	 * character is executing<br>
	 * </li>
	 *
	 * <li>actionId: The index of the action that the character is
	 * executing @see Action<br>
	 * </li>
	 *
	 * <li>hp: The amount of the HP<br>
	 * </li>
	 *
	 * <li>energy: The amount of the energy<br>
	 * </li>
	 *
	 * <li>x: The x coordinate of the character box's top-left corner when
	 * {@code isLeft} is {@code true}, or the one's top-right corner when
	 * {@code isLeft} is {@code false}<br>
	 * </li>
	 *
	 * <li>y: The y coordinate of the character box's top-left corner<br>
	 * </li>
	 *
	 * <li>keyByte: The key of the action that the character is executing
	 * represented in byte</li>
	 * </ul>
	 *
	 * @param file
	 *            The file to analyze
	 */
	public void analyze(File file) {
		boolean[] isLeft = new boolean[2];
		byte[] actionRemainingFrames = new byte[2];
		byte[] actionId = new byte[2];
		int[] hp = new int[2];
		int[] energy = new int[2];
		int[] x = new int[2];
		int[] y = new int[2];
		byte[] keyByte = new byte[2];
		// USER declare
		ArrayList<Integer> lastindex = new ArrayList<Integer>();
		ArrayList<Integer> lastact = new ArrayList<Integer>();
		int deltax;
		int deltay;
		int index;
		int playerlastaction = Action.STAND.ordinal();
		//int actionpredict;
		boolean projectiletrigger = false;
		int projectilecountdown = 0;
		int projectile;

		String[] actName = new String[2];
		Key[] key = { new Key(), new Key() };

		// Creates the output file
		File outputFile = openOutputFile(file);

		// Writes the header to the output file
		try {
			dis = new DataInputStream(new FileInputStream(file));
			pw = new PrintWriter(new BufferedWriter(new FileWriter(outputFile)));
			writeHeader();
		} catch (Exception e) {
			e.printStackTrace();
		}

		// Extracts the frames information and analyzes them
		for (int round = 0; round < 3; round++) {
			for (int count = 1; count <= 3600; count++) {
				for (int i = 0; i < 2; i++) {
					try {
						isLeft[i] = dis.readBoolean();
						actionRemainingFrames[i] = dis.readByte();
						actionId[i] = dis.readByte();
						hp[i] = dis.readInt();
						energy[i] = dis.readInt();
						x[i] = dis.readInt();
						y[i] = dis.readInt();
						keyByte[i] = dis.readByte();

						// Searches the action name
						for (Action act : Action.values()) {
							if (act.ordinal() == actionId[i]) {
								// System.out.println(i);
								// System.out.println(actionId[i]);
								actName[i] = act.name();
								break;
							}
						}

						// Converts key represented in byte to boolean
						// respectively
						key[i] = key[i].convertByteToKey(keyByte[i]);

						// If HP is less than 0, it is set to 0
						if (HP_MODE && hp[i] < 0) {
							hp[i] = 0;
						}
					} catch (Exception e) {
						fileClose();
						e.printStackTrace();
						System.exit(0);
					}
				}

				// USER CODE
				// find situation code
				deltax = x[0] - x[1];
				if (deltax < 0)
					deltax = -deltax;
				deltax = DxtoCode(deltax);
				deltay = DytoCode(y[0], y[1]);
				/*
				 * if(actionId[1]==100){ System.out.println("wtf"); }
				 */
				// System.out.println(actionId[1]+" "+deltax+" "+ deltay+" "+
				// EtoCode(energy[0])+" "+ EtoCode(energy[1]));
				// System.exit(0);
				if (actionId[1] == Action.STAND_D_DF_FA.ordinal() || actionId[1] == Action.STAND_D_DF_FB.ordinal()
						|| actionId[1] == Action.STAND_D_DF_FC.ordinal()) {
					projectiletrigger = true;
				} else {
					if (projectiletrigger) {
						projectilecountdown = 60;
					}
					projectiletrigger = false;
				}
				if (projectilecountdown > 0) {
					projectilecountdown--;
				}
				projectile = projectilecountdown > 0 ? 1 : 0;
				index = Encrypt(playerlastaction, deltax, deltay, EtoCode(energy[0]), EtoCode(energy[1]), projectile,Checkcorner(x[0],x[1]),enemystate(actionId[1]));
				// add index to the list
				while (lastindex.size() < 15) {
					lastindex.add(-1);
				}
				lastindex.add(index);
				while (lastindex.size() > 15) {
					lastindex.remove(0);
				}
				// if player react, return 15 frames to retrieve index
				// if(playerlastaction == Action.STAND.ordinal())
				// System.out.println(playerlastaction + " : " + actionId[0]);
				if (playerlastaction == Action.STAND.ordinal() && actionId[0] != Action.STAND.ordinal()) {
					index = lastindex.get(0);
					// System.out.println(index + " " + count);
					if (index == -1) {
						playerlastaction = actionId[0];
						continue;
					}
				} else {
					// nothing to gather here
					playerlastaction = actionId[0];
					continue;
				}
				// System.out.println("something's coming");
				// add player action to the script
				if (ACTIONLIST[actionId[0]] != 0)
					Act.get(index).add(ACTIONLIST[actionId[0]]);
				// if there are more than 100 the first get removed
				if (Act.get(index).size() > 100) {
					Act.get(index).remove(0);
				}
				// (optional not yet implement) Remove an instance of move which
				// become another such as dash and forward

				// remember player last action
				playerlastaction = actionId[0];
				/*
				 * if (Act[index] == 63) { if (lastactionid == 0 || lastactionid
				 * == 1 || lastactionid == 2 || lastactionid == 3 ||
				 * lastactionid == 9) { if (actionId[0] != lastactionid) {
				 * if(ACTIONLIST[actionId[0]] != 0){ Act[index] =
				 * ACTIONLIST[actionId[0]]; } } } } lastactionid = actionId[0];
				 */
				// END

				// Outputs the extracted frame information to the output file
				pw.print(hp[0] + "," + hp[1] + "," + energy[0] + "," + energy[1] + "," + x[0] + "," + x[1] + "," + y[0]
						+ "," + y[1] + "," + actName[0] + "," + actName[1] + ",");

				for (int i = 0; i < 2; i++) {
					pw.print(key[i].A + "," + key[i].B + "," + key[i].C + "," + key[i].U + "," + key[i].R + ","
							+ key[i].D + "," + key[i].L + ",");
				}

				pw.println(isLeft[0] + "," + isLeft[1]);

				// If the round changes, writes one blank line
				if ((HP_MODE && (hp[0] <= 0 || hp[1] <= 0)) || count == 3600) {
					pw.println();
					break;
				}
			}
		}
		outputFile.deleteOnExit();
	}

	/**
	 * Writes the header to the output file.<br>
	 * In this project, the following information is used as the header.<br>
	 * <ul>
	 * <li>Each character's max HP<br>
	 * </li>
	 * <li>Each character's name<br>
	 * </li>
	 * </ul>
	 * If you don't need the header, please comment out {@code pw.println}
	 */
	public void writeHeader() {
		String[] characterName = new String[2];
		int[] maxHp = new int[2];
		int temp;

		try {
			if ((temp = dis.readInt()) == -1) {
				maxHp[0] = dis.readInt();
				characterName[0] = CHARACTERS[dis.readInt()];
				dis.readInt(); // Skip
				maxHp[1] = dis.readInt();
				characterName[1] = CHARACTERS[dis.readInt()];
				HP_MODE = true;

				// If you don't need the header, please comment out these 3
				// lines
				 pw.println("P1's max HP" + "," + maxHp[0] + "," + "P1's character" + "," + characterName[0]);
				 pw.println("P2's max HP" + "," + maxHp[1] + "," + "P2's character" + "," + characterName[1]);
				 pw.println();
			} else {
				characterName[0] = CHARACTERS[temp];
				characterName[1] = CHARACTERS[dis.readInt()];
				HP_MODE = false;

				// If you don't need the header, please comment out these 3
				// lines
				pw.println("P1's character" + "," + characterName[0]);
				pw.println("P2's character" + "," + characterName[1]);
				pw.println();
			}

			pw.print("P1's HP,P2's HP,P1's Energy,P2's Energy,P1's x,P2's x,P1's y,P2's y,P1's Action,P2's Action,");
				pw.print("P1's key.A,P1's key.B,P1's key.C,P1's key.U,P1's key.R,P1's key.D,P1's key.L,P2's key.A," + "P2's key.B,P2's key.C,P2's key.U,P2's key.R,P2's key.D,P2's key.L,");

				pw.println("P1's isLeft,P2's isLeft");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Creates the output file
	 *
	 * @param file
	 *            The read file
	 *
	 * @return Output file
	 */
	public File openOutputFile(File file) {
		String fileName = file.getName();
		String subFileName = fileName.substring(fileName.indexOf("_") + 1, fileName.lastIndexOf("_"));
		int index = 0;
		File resultFile;

		// If the same file exists, increments index and try to recreate
		fileName = OUTPUT_PATH + subFileName + "_" + index + ".csv";
		while ((resultFile = new File(fileName)).exists()) {
			fileName = OUTPUT_PATH + subFileName + "_" + ++index + ".csv";
		}

		return resultFile;
	}

	/** Closes all files */
	public void fileClose() {
		try {
			dis.close();
			pw.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// USER method
	public int Encrypt(int actionid, int deltax, int deltay, int penergy, int eenergy, int projectile, int corner,
			int enemystate) {
		return projectile + eenergy * 2 + penergy * 2 * 3 + deltay * 2 * 9 + deltax * 18 * 16 + corner * 18 * 16 * 21
				+ enemystate * 18 * 16 * 21 * 3 /*+ actionid * 18 * 16 * 21 * 3 * 5*/;
	}

	public int enemystate(int enemyaction){
		if(enemyaction<=9){
			return 0;
		}
		if(enemyaction<=12){
			return 2;
		}
		if(enemyaction<=18){
			return 3;
		}
		if(enemyaction<=22||enemyaction == 26){
			return 4;
		}
		return 1;
	}
	
	public int Checkcorner(int selfx, int enemyx) {
		if (selfx < 0) {
			if (enemyx > selfx) {
				return 1;
			} else {
				return 2;
			}
		}
		if (selfx > 560) {
			if (enemyx < selfx) {
				return 1;
			} else {
				return 2;
			}
		}
		if(enemyx < 0 || enemyx > 580){
			return 2;
		}
		return 0;
	}

	public int EtoCode(int energy) {
		if (energy < 20) {
			return 0;
		}
		if (energy < 150) {
			return 1;
		}
		return 2;
	}

	public int DxtoCode(int dx) {
		if (dx > 200) {
			return 20;
		} else
			return dx / 10;
	}

	public int DytoCode(int py, int ey) {
		int ans = 0;
		if (py > 0) {
			if (py > 400) {
				py = 399;
			}
			ans += (py / 100) * 4;
		}
		if (ey > 0) {
			if (ey > 400) {
				ey = 399;
			}
			ans += (ey / 100);
		}
		return ans;
	}

}
